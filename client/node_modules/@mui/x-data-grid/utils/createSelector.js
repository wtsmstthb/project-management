"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSelectorMemoized = exports.createSelector = exports.createRootSelector = void 0;
var _reselect = require("reselect");
var _useGridSelector = require("../hooks/utils/useGridSelector");
var _weakMapMemoize = require("./weakMapMemoize");
const reselectCreateSelector = (0, _reselect.createSelectorCreator)({
  memoize: _reselect.lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  },
  argsMemoize: _weakMapMemoize.weakMapMemoize
});
const cache = new WeakMap();
const createSelector = (a, b, c, d, e, f, ...other) => {
  if (other.length > 0) {
    throw new Error('Unsupported number of selectors');
  }
  let selector;

  // eslint-disable-next-line id-denylist
  if (a && b && c && d && e && f) {
    selector = (apiRef, args) => {
      const va = a(apiRef, args);
      const vb = b(apiRef, args);
      const vc = c(apiRef, args);
      const vd = d(apiRef, args);
      const ve = e(apiRef, args);
      return f(va, vb, vc, vd, ve, args);
    };
    // eslint-disable-next-line id-denylist
  } else if (a && b && c && d && e) {
    selector = (apiRef, args) => {
      const va = a(apiRef, args);
      const vb = b(apiRef, args);
      const vc = c(apiRef, args);
      const vd = d(apiRef, args);
      return e(va, vb, vc, vd, args);
    };
  } else if (a && b && c && d) {
    selector = (apiRef, args) => {
      const va = a(apiRef, args);
      const vb = b(apiRef, args);
      const vc = c(apiRef, args);
      return d(va, vb, vc, args);
    };
  } else if (a && b && c) {
    selector = (apiRef, args) => {
      const va = a(apiRef, args);
      const vb = b(apiRef, args);
      return c(va, vb, args);
    };
  } else if (a && b) {
    selector = (apiRef, args) => {
      const va = a(apiRef, args);
      return b(va, args);
    };
  } else {
    throw new Error('Missing arguments');
  }
  return selector;
};

/**
 * Used to create the root selector for a feature. It assumes that the state is already initialized
 * and strips from the types the possibility of `apiRef` being `null`.
 * Users are warned about this in our documentation https://mui.com/x/react-data-grid/state/#direct-selector-access
 */
exports.createSelector = createSelector;
const createRootSelector = fn => (apiRef, args) => fn(apiRef.current.state, args);
exports.createRootSelector = createRootSelector;
const createSelectorMemoized = (...args) => {
  const selector = (apiRef, selectorArgs) => {
    const cacheKey = apiRef.current.instanceId;
    const cacheArgsInit = cache.get(cacheKey);
    const cacheArgs = cacheArgsInit ?? new Map();
    const cacheFn = cacheArgs.get(args);
    if (cacheArgs && cacheFn) {
      if (!(0, _useGridSelector.argsEqual)(cacheFn.selectorArgs, selectorArgs)) {
        const reselectArgs = selectorArgs !== undefined ? [...args.slice(0, args.length - 1), () => selectorArgs, args[args.length - 1]] : args;
        const fn = reselectCreateSelector(...reselectArgs);
        fn.selectorArgs = selectorArgs;
        cacheArgs.set(args, fn);
        return fn(apiRef, selectorArgs);
      }
      return cacheFn(apiRef, selectorArgs);
    }
    const reselectArgs = selectorArgs !== undefined ? [...args.slice(0, args.length - 1), () => selectorArgs, args[args.length - 1]] : args;
    const fn = reselectCreateSelector(...reselectArgs);
    fn.selectorArgs = selectorArgs;
    if (!cacheArgsInit) {
      cache.set(cacheKey, cacheArgs);
    }
    cacheArgs.set(args, fn);
    return fn(apiRef, selectorArgs);
  };
  return selector;
};
exports.createSelectorMemoized = createSelectorMemoized;